<html lang="en">
	<head>
        <meta charset="utf-8" />
        <title>Proyecto 2 - Gr√°ficos II</title>
        <script src="js/jquery.js"></script>
        <script src='js/threex.domevent.js'></script>
        <script src="js/three.js"></script>
        <script src="js/regression.js"></script>
        <script src="js/Detector.js"></script>
    </head>
    <body>
    	<script>
    		var lastPoint = null;
            var container,i;
			var camera, scene, projector, renderer;
			var particleMaterial;
			var objects = [];
            var isRotating=false;
            var buffer = []; //Guarda las lineas que se dibujan y luego es vaciado
            var puntos = []; //Guarda los puntos dibujados en cada trazo
            var stickFigure =  {};

            function get3dPointZAxis(event)
            {
                var vector = new THREE.Vector3(
                    ( event.clientX / window.innerWidth ) * 2 - 1,
                    - ( event.clientY / window.innerHeight ) * 2 + 1,
                    0.5 );
                projector.unprojectVector( vector, camera );
                var dir = vector.sub( camera.position ).normalize();
                var distance = - camera.position.z / dir.z;
                var pos = camera.position.clone().add( dir.multiplyScalar( distance ) );    
                return pos;
            }

            init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );
				
				

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 0, 300, 500 );

				scene = new THREE.Scene();

				projector = new THREE.Projector();

				if ( Detector.webgl )
                    renderer = new THREE.WebGLRenderer( {antialias:true} );
                else
                    renderer = new THREE.CanvasRenderer();
                    
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild( renderer.domElement );

				
				document.addEventListener( 'mousedown', startDraw, false );
                document.addEventListener( 'mouseup', stopDraw, false );
                document.addEventListener( 'mousemove', doDraw, false );				

                window.addEventListener( 'resize', onWindowResize, false );
			}

			function startDraw(event)
            {
                lastPoint = get3dPointZAxis(event);
                puntos = [];
            }

            function stopDraw(event)
            {
                lastPoint = null;
                console.log(puntos);
                for (i=0; i<buffer.length; i++){
                	scene.remove(buffer[i]);
                }
                buffer=[];
                var shape = recognizeStroke(puntos);
                if (shape) {
                    scene.add(shape);
                }
            }

            function doDraw(event)
            {    
                if( lastPoint )
                {
                    var pos = get3dPointZAxis(event);
                    var material = new THREE.LineBasicMaterial({
                        color: 0x0000ff
                    });
                    var geometry = new THREE.Geometry();
                    if( Math.abs(lastPoint.x - pos.x) < 500 && Math.abs(lastPoint.y - pos.y) < 500 && Math.abs(lastPoint.z - pos.z) < 500 )
                    {
                        geometry.vertices.push(lastPoint);
                        geometry.vertices.push(pos);

                        puntos.push(pos);

                        var line = new THREE.Line(geometry, material);
                        buffer.push(line);
                        scene.add(line);
                        lastPoint = pos;        
                    }
                    else
                    {
                        console.debug(lastPoint.x.toString() + ':' + lastPoint.y.toString() + ':' + lastPoint.z.toString()  + ':' + 
                                    pos.x.toString() + ':' + pos.y.toString()  + ':' + pos.z.toString());
                    }
                }
            }

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				

			}


			function render() {
				renderer.render( scene, camera );
			}

            function recognizeStroke(points) {

                var touchMoveX = [];
                var touchMoveY = [];

                points.forEach(function (point) {
                    touchMoveX.push(point.x);
                    touchMoveY.push(point.y);
                });

                var totalAmount = points.length;



                // sum up all coordinates and divide them by total length 
                // the average is a cheap approximation of the center.
                var averageX = touchMoveX.reduce( function ( previous, current) {
                    return previous + current;
                } ) / totalAmount ;
                var averageY = touchMoveY.reduce( function ( previous, current) {
                    return previous + current;
                } ) / totalAmount ;

                // compute distance to approximated center from each point
                var distances = touchMoveX.map ( function ( x, index ) {
                    var y = touchMoveY[index];        
                    return Math.sqrt( Math.pow(x - averageX, 2) + Math.pow(y - averageY, 2) );
                } );
                // average of those distance is 
                var averageDistance = distances.reduce ( function ( previous, current ) {
                    return previous + current;
                } ) / distances.length;

                var min = averageDistance * 0.75;
                var max = averageDistance * 1.33;
                // filter out the ones not inside the min and max boundaries 
                var inRange = distances.filter ( function ( d ) {
                   return d > min && d < max;
                } );

                var minPercentInRange = 70;
                var percentInRange = inRange.length / totalAmount * 100;

                var data = points.map(function (point) { return [point.x, point.y] });
                var linear = regression('linear', data);
                var poli = regression('polynomial', data,2);
                var exp = regression('exponential', data);

                var regs = [linear,poli,exp];
                console.log(regs);
                var sortedR2s = regs.map(function (reg) {
                    return reg.r2;
                }).sort();
                console.log(sortedR2s);

                

                // by the % of points within those boundaries we can guess if it's circle
                if ( !stickFigure.head && !stickFigure.body && percentInRange > minPercentInRange ) {
                    console.log('Stroke is a head');
                    var headDetails = {centroid: {x: averageX, y: averageY}, radius: averageDistance};
                    stickFigure.head = headDetails;
                    return drawCircle(headDetails.centroid, headDetails.radius);
                } else {
                    console.log(min);
                    console.log(max);
                    console.log(distances);
                    console.log(inRange);
                    console.log('Stroke is not recognized');
                    return null;
                }
            }

            function drawCircle(centroid, radius) {
                var radius = radius,
                segments = 64,
                material = new THREE.LineBasicMaterial( { color: 0x0000ff } ),
                geometry = new THREE.CircleGeometry( radius, segments );

                // Remove center vertex
                geometry.vertices.shift();

                geometry.applyMatrix( new THREE.Matrix4().makeTranslation(centroid.x, centroid.y, 0) );
                //geometry.translate( centroid.x, centroid.y, 0 );

                return new THREE.Line( geometry, material );
            }
            
    	</script>
    	<div>
    		<canvas id="myCanvas" width="100%" height="100%">
    	</div>
    </body>
</html>