<html lang="en">
	<head>
        <meta charset="utf-8" />
        <title>Proyecto 2 - Gr√°ficos II</title>
        <script src="js/jquery.js"></script>
        <script src='js/threex.domevent.js'></script>
        <script src="js/three.js"></script>
        <script src="js/Detector.js"></script>
    </head>
    <body>
    	<script>
    		var lastPoint = null;
            var container,i;
			var camera, scene, projector, renderer;
			var particleMaterial;
			var objects = [];
            var isRotating=false;
            var buffer = []; //Guarda las lineas que se dibujan y luego es vaciado
            var puntos = []; //Guarda los puntos dibujados en cada trazo
            function get3dPointZAxis(event)
            {
                var vector = new THREE.Vector3(
                    ( event.clientX / window.innerWidth ) * 2 - 1,
                    - ( event.clientY / window.innerHeight ) * 2 + 1,
                    0.5 );
                projector.unprojectVector( vector, camera );
                var dir = vector.sub( camera.position ).normalize();
                var distance = - camera.position.z / dir.z;
                var pos = camera.position.clone().add( dir.multiplyScalar( distance ) );    
                return pos;
            }

            init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );
				
				

				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 0, 300, 500 );

				scene = new THREE.Scene();

				projector = new THREE.Projector();

				if ( Detector.webgl )
                    renderer = new THREE.WebGLRenderer( {antialias:true} );
                else
                    renderer = new THREE.CanvasRenderer();
                    
				renderer.setClearColor( 0xf0f0f0 );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.appendChild( renderer.domElement );

				
				document.addEventListener( 'mousedown', startDraw, false );
                document.addEventListener( 'mouseup', stopDraw, false );
                document.addEventListener( 'mousemove', doDraw, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function startDraw(event)
            {
                lastPoint = get3dPointZAxis(event);
                puntos = [];
            }

            function stopDraw(event)
            {
                lastPoint = null;
                console.log(puntos);
                for (i=0; i<buffer.length; i++){
                	scene.remove(buffer[i]);
                }
                buffer=[];
            }

            function doDraw(event)
            {    
                if( lastPoint )
                {
                    var pos = get3dPointZAxis(event);
                    var material = new THREE.LineBasicMaterial({
                        color: 0x0000ff
                    });
                    var geometry = new THREE.Geometry();
                    if( Math.abs(lastPoint.x - pos.x) < 500 && Math.abs(lastPoint.y - pos.y) < 500 && Math.abs(lastPoint.z - pos.z) < 500 )
                    {
                        geometry.vertices.push(lastPoint);
                        geometry.vertices.push(pos);

                        puntos.push(pos);

                        var line = new THREE.Line(geometry, material);
                        buffer.push(line);
                        scene.add(line);
                        lastPoint = pos;        
                    }
                    else
                    {
                        console.debug(lastPoint.x.toString() + ':' + lastPoint.y.toString() + ':' + lastPoint.z.toString()  + ':' + 
                                    pos.x.toString() + ':' + pos.y.toString()  + ':' + pos.z.toString());
                    }
                }
            }

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				

			}


			function render() {
				renderer.render( scene, camera );
			}
            
    	</script>
    	<div>
    		<canvas id="myCanvas" width="100%" height="100%">
    	</div>
    </body>
</html>